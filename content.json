{"pages":[],"posts":[{"title":"Android中的多线程(一)","text":"进程和线程 线程的四种属性 线程的六个方法 线程的六种状态 进程和线程进程：进程是系统进行资源分配和调度的独立单位。在现代操作系统中，一个运行的程序或者一个动态指令集通常对应一个进程。对于Android系统来讲，正常情况下一个程序启动后只会运行在一个进程中，但如果需要某些组件（如Activity、Service）运行在单独的进程中，可以通过在AndroidMantifest中指定android:process来使其运行在指定的线程中。 线程：线程是CPU调度的基本单位，一个进程中可以有多个并发的线程，多个线程共享所在进程的资源，包括共享内存，公有数据，全局变量等 调度器： Java程序中，JVM负责线程的调度，线程的调度是按照特定的机制为多个线程分配CPU的使用权。调度的模式有两种：分时调度和抢占式调度。分时调度是指所有线程轮流获得CPU的使用权，并平均分配每个线程占用CPU的时间；抢占式调度是根据线程的优先级别来获取CPU的使用权。JVM的线程调度模式采用抢占式模式。 线程的四种属性 编号-tid 线程的编号（id）用于标识不同的线程，每条线程拥有不同的编号。需要注意的是，编号不能作为唯一标示，某个线程运行结束后，该编号可能被新的线程重用。编号是只读的不能被修改 名称-name 线程的默认名称是Thread-线程编号，在新建线程时我们可以通过构造函数来为线程命名 1Thread thread=new Thread(&quot;name&quot;); 类别-daemon 守护线程（DaemonThread） 守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。我们可以通过 setDaemon(true) 把线程设置为守护线程。 用户线程 默认创建的都是用户线程 优先级-priority JVM的线程调度方式为抢占式，优先级的高低决定了调度器会优先运行哪个线程。java中线程优先级的范围为 1~10，默认值是 5，Thread 中定义了下面三个优先级常量。 优先级 名称 值 最低优先级 MIN_PRIORITY 1 默认优先级 NORM_PRIORITY 5 最高优先级 MAX_PRIORITY 10 线程的六个方法 start() 该方法用于启动线程，需要注意的是：start()只能调用一次，再次调用会抛出异常 run() 重写Thread或者Runnable所需要实现的方法，为任务的具体逻辑，该方法由JVM调用，一般不需要手动调用 join() 用于等待其他线程结束后继续执行，如A线程运行中，B线程调用了A线程的join()，那么A线程会停止执行等待B线程执行结束后继续执行。join() 方法导致的等待状态是可以被中断的，所以调用这个方法需要捕获中断异常 12345678910111213141516171819202122public static void main(String[] args) { Thread threadB = new Thread(() -&gt; { System.out.println(&quot;B:你先等等，我先来&quot;); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;B:好了，我走了&quot;); }); Thread threadA = new Thread(() -&gt; { System.out.println(&quot;A:我要开始装逼了&quot;); try { threadB.start(); threadB.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;A:我又开始了&quot;); }); threadA.start(); } 让我们开始装～，哦不对运行 Thread.currentThread() currentThread() 方法是一个静态方法，用于获取执行当前方法的线程。 我们可以在任意方法中调用 Thread.currentThread() 获取当前线程，并设置它的名字和优先级等属性。 Thread.yield() 用于使当前线程放弃对处理器的占用，如果有其他线程需要运行，当前线程会处于暂停状态 调用该方法就像是是对线程调度器说：“如果其他线程要处理器资源，那就给它们，否则我继续用”。该方法不一定会让线程进入暂停状态。 Thread.sleep(ms) 用于使当前线程在指定时间内休眠（暂停)，该状态可能会被中断，也需要捕获异常 线程的状态 新建状态 当线程创建完毕，未调用start ()时处于新建状态 就绪状态 调用start()后，此时线程处于就绪状态也就是可运行状态，此时还不会执行run()方法 运行状态 当调度器调用该线程后，该线程会执行run()方法，线程处于运行状态 阻塞状态 当下面几种情况发生时，线程就处于阻塞（BLOCKED）状态。 发起阻塞式 I/O 操作 其他线程调用join()方法 调用sleep()方法 申请其他线程持有的锁 进入一个 synchronized 方法或代码块失败 死亡状态 当线程的任务执行完毕或者任务执行遇到异常时，线程就处于终止（TERMINATED）状态，线程死亡后不能再被重新启动","link":"/2020/11/24/Android%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"RecyclerView相关(一)","text":"ListView的局限 只有纵向列表一种布局 没有动画API 没有强制实现ViewHolder RecyclerView的优势 默认支持LinearLayout、GridLayout、StaggeredLayout三种布局 友好的动画API 强制实现ViewHolder 性能比ListView要好 布局灵活，可以自定义LayoutManager RecyclerView的缓存机制共有四层缓存 Scrap 屏幕内的itemview Cache ViewCachedExtension 自定义的cache策略，有则用无则不用 RecycledViewPool Scrap和Cache与postion相关，不需要重新创建和绑定，RecycledViewPool只关心viewtype，会执行onBindViewHolder() RecyclerView性能优化策略 使用LinearLayoutManager.setInitialPrefetchItemCount() 用户滑动到横向滑动的Item RecyclerView的时候，由于需要创建更复杂的RecyclerView以及多个子View，可能会导致页面卡顿 由于RenderThered的存在，RecyclerView会prefetch LinearLayoutManager.setInitialPrefetchItemCount()横向列表初次显示时可见的item个数 只有LinearLayoutManager有这个API 只有嵌套在内部的RecyclerView才会生效 RecyclerView.setHasFixedSize() 如果Adapter的数据变化不会导致RecyclerView的大小变化，在数据发生变化后将直接调用layoutChildren()而不是requestLayout() 多个RecyclerView公用RecycledViewPool DiffUtil 计算两个列表的差异，输出针对差异的操作，将第一个列表变成第二个","link":"/2021/05/24/RecyclerView/"},{"title":"Android中的多线程(二)","text":"创建线程多线程的实现一般有三种方法，其中最长用的有前两种方法。 继承Thread类，重写run()方法Thread本质上是实现了Runnable接口的一个类。需要注意的是调用start()方法后，并不是立即执行该线程的任务，而是使线程变成可运行状态，什么时候运行该线程是由系统所调度的。 12345class TestThread : Thread() { override fun run() { println(&quot;Hello&quot;) }} 实例化该线程对象，调用start()方法 12val testThread = TestThread()testThread.start() 实现Runnable接口，并实现run()方法123456789101112131415class TestRunnable : Runnable { override fun run() { println(&quot;Hello&quot;) }}object Test { @JvmStatic fun main(args: Array&lt;String&gt;) { val testRunnable = TestRunnable() val testThread = Thread(testRunnable) testThread.start() }} 实现Callable接口，重写call()方法Callbale接口实际是属于Executor框架中的功能类，Callable接口与Runnable接口相似，但提供了比Runnable更强大的功能： (1) Callable可以提供返回值，Runnable则不能 (2) Callable的call方法可以抛出异常，二Runnable的run方法则不能 (3) 运行Callable会返回一个Future对象，Future对象表示异步计算返回的结果。调用Future的get方法获取结果时，会阻塞当前线程，直到call方法返回结果 1234567891011121314151617181920object Test { @JvmStatic fun main(args: Array&lt;String&gt;) { val callable = TestCallable() val executorService = Executors.newSingleThreadExecutor() val future = executorService.submit(callable) try { println(future.get()) } catch (e: Exception) { e.printStackTrace() } }}class TestCallable : Callable&lt;String&gt; { override fun call(): String { return &quot;Hello&quot; }}","link":"/2021/10/08/Android%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"OkHttp","text":"OkHttp的基本用法1.1 配置gradle，引入okhttp依赖1234// okhttp依赖implementation &quot;com.squareup.okhttp3:okhttp:4.9.0&quot;// okhttp日志拦截器implementation &quot;com.squareup.okhttp3:logging-interceptor:4.9.0&quot; 1.2 OkHttp的简单使用123456789101112131415161718192021222324252627282930// 同步Get请求 fun syncGet(url: String): String? { val client = OkHttpClient() val request = Request.Builder() .url(url) .build() val response = client.newCall(request).execute() return response.body?.string() } // 异步Get请求 fun asyncGet(url: String, callback: Callback) { val client = OkHttpClient() val request = Request.Builder() .url(url) .build() client.newCall(request).enqueue(callback) } // 异步Post请求 fun asyncPost(url: String, body: String, callback: Callback) { val client = OkHttpClient() val requestBody = body.toRequestBody() val request = Request.Builder() .url(url) .post(requestBody) .build() client.newCall(request).enqueue(callback) } OkHttp源码解析从基本用法我们知道，一个请求的 执行都是通过client.newCall()来发起的,这里newCall()返回的实际上是一个RealCall对象 1override fun newCall(request: Request): Call = RealCall(this, request, forWebSocket = false) RealCall是Call接口的实现,我们先来看下Call接口的各个方法 1234567891011121314151617181920212223242526272829interface Call : Cloneable { // 返回一个原始的请求 fun request(): Request // 立即执行该请求，同步方法会阻塞当前线程 fun execute(): Response // 异步执行该请求，请求结果会通过回调返回 fun enqueue(responseCallback: Callback) // 取消请求，若是请求已完成则不能取消 fun cancel() // 是否执行过请求，一个请求只能被执行一次 fun isExecuted(): Boolean // 该请求是否已经取消 fun isCanceled(): Boolean // 返回该请求的时间配置 fun timeout(): Timeout // 创建一个新的请求，该请求可以被再次执行 public override fun clone(): Call fun interface Factory { fun newCall(request: Request): Call }} 接下来我们通过RealCalld的execute()来分析网络请求的执行过程 12345678910111213141516171819202122232425262728293031class RealCall( val client: OkHttpClient, val originalRequest: Request, val forWebSocket: Boolean) : Call { ··· override fun execute(): Response { // 检查该请求是否被执行过 check(executed.compareAndSet(false, true)) { &quot;Already Executed&quot; } timeout.enter() // eventListener callStart() try { // 将该请求记录到dispatcher client.dispatcher.executed(this) // 通过拦截器责任链来执行请求，真正进行网络请求的地方 return getResponseWithInterceptorChain() } finally { client.dispatcher.finished(this) } } ···}class Dispather{ ··· @Synchronized internal fun executed(call: RealCall) { runningSyncCalls.add(call) } ···} 调用excute()方法首先会检查该请求是否被执行过，若是执行过会直接抛出异常，然后timeout.enter()将计时器开始计时，用来判断请求是否超时。再将该请求加入到dispather的请求队列中，因为是同步方法，这个队列只是用来记录该请求。最后调用getResponseWithInterceptorChain()通过一系列拦截器来进行请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748internal fun getResponseWithInterceptorChain(): Response { // 拦截器列表 val interceptors = mutableListOf&lt;Interceptor&gt;() // 用户自定义拦截器 interceptors += client.interceptors // 重试和重定向拦截器 interceptors += RetryAndFollowUpInterceptor(client) // 桥接拦截器 构建用户请求参数、Header等 interceptors += BridgeInterceptor(client.cookieJar) // 缓存拦截器 interceptors += CacheInterceptor(client.cache) // 网络连接拦截器 interceptors += ConnectInterceptor if (!forWebSocket) { interceptors += client.networkInterceptors } // 请求服务拦截器 真正执行请求的地方 interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain( call = this, interceptors = interceptors, index = 0, exchange = null, request = originalRequest, connectTimeoutMillis = client.connectTimeoutMillis, readTimeoutMillis = client.readTimeoutMillis, writeTimeoutMillis = client.writeTimeoutMillis ) var calledNoMoreExchanges = false try { // 执行拦截器 val response = chain.proceed(originalRequest) if (isCanceled()) { response.closeQuietly() throw IOException(&quot;Canceled&quot;) } return response } catch (e: IOException) { calledNoMoreExchanges = true throw noMoreExchanges(e) as Throwable } finally { if (!calledNoMoreExchanges) { noMoreExchanges(null) } }} 可以看到，该方法将一系列的拦截器、request组装成RealInterceptorChain，构造成了okhttp的责任链，通过该责任链对请求进行一系列的处理并返回请求结果，正是OkHttp的精髓所在 12345678910111213141516171819202122232425262728293031override fun proceed(request: Request): Response { // 检查拦截器的下标 check(index &lt; interceptors.size) calls++ // 重定向 if (exchange != null) { check(exchange.finder.sameHostAndPort(request.url)) { &quot;network interceptor ${interceptors[index - 1]} must retain the same host and port&quot; } check(calls == 1) { &quot;network interceptor ${interceptors[index - 1]} must call proceed() exactly once&quot; } } // [1] 通过index+1拿到下一个拦截器 val next = copy(index = index + 1, request = request) val interceptor = interceptors[index] // 执行拦截器并将下一个拦截器传入，当前拦截器处理完成后会执行下一个拦截器 @Suppress(&quot;USELESS_ELVIS&quot;) val response = interceptor.intercept(next) ?: throw NullPointerException( &quot;interceptor $interceptor returned null&quot;) if (exchange != null) { check(index + 1 &gt;= interceptors.size || next.calls == 1) { &quot;network interceptor $interceptor must call proceed() exactly once&quot; } } check(response.body != null) { &quot;interceptor $interceptor returned a response with no body&quot; } return response } RealInterceptorChain通过index的递增拿到下一个拦截器来完成拦截器链的遍历","link":"/2021/10/11/OkHttp%E8%A7%A3%E6%9E%90/"},{"title":"HashMap","text":"HashMapHashMap是一个用于储存key-value键值对的集合，每一个键值对就是一个Entity.这些Entity分散储存在一个数组中，这个数组就是HashMap的主干。 HashMap数组每一个元素的初始值都是Null HashMap的put过程比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）： index = Hash（“apple”） 假定最后计算出的index是2，那么结果如下： 但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。比如下面这样： 这时候该怎么办呢？我们可以利用链表来解决。 HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可： 需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。 Get方法的原理首先会把输入的Key做一次Hash映射，得到对应的index： index = Hash（“apple”） 由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”： 第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。 第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。 之所以把Entry6放在头节点，是因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。 HashMap初始长度为16，每次初始化或扩容时长度必须为2的幂次方。之所以这样规定，是因为从Key映射到数组的位置时，用用到hash()函数，为了实现高效的算法hash()采用了位运算： ​ index = HashCode（Key） &amp; （Length - 1） 我们以值为“book”的Key来演示整个过程： 1.计算book的hashcode，结果为十进制的3029737，二进制的101110001110101110 1001。 2.假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111。 3.把以上两个结果做与运算，101110001110101110 1001 &amp; 1111 = 1001，十进制是9，所以 index=9。 可以说，Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。 长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。","link":"/2021/09/10/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"Window和WindowManager","text":"Window表示一个窗口的概念，在某些时候我们需要在桌面上显示一个类似于悬浮窗的东西，那么我们可以通过Window来实现。Window是一个抽象类，他的唯一具体实现是PhoneWindow。Android的所有视图都是通过Window来呈现的，不管是Activity、Dialog、还是Toast，它们的视图都是基于Window的，因此Window实际是View的管理者。 WindowManager是Window的管理类，我们通过WindowManager来对window进行创建、添加和移除 添加WindowmButton= new Button(this);","link":"/2021/05/06/Window%E5%92%8CWindowManager/"}],"tags":[{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"Window","slug":"Window","link":"/tags/Window/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"okhttp","slug":"okhttp","link":"/tags/okhttp/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"}],"categories":[]}