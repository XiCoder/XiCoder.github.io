{"pages":[],"posts":[{"title":"Android中的多线程(一)","text":"进程和线程 线程的四种属性 线程的六个方法 线程的六种状态 进程和线程进程：进程是系统进行资源分配和调度的独立单位。在现代操作系统中，一个运行的程序或者一个动态指令集通常对应一个进程。对于Android系统来讲，正常情况下一个程序启动后只会运行在一个进程中，但如果需要某些组件（如Activity、Service）运行在单独的进程中，可以通过在AndroidMantifest中指定android:process来使其运行在指定的线程中。 线程：线程是CPU调度的基本单位，一个进程中可以有多个并发的线程，多个线程共享所在进程的资源，包括共享内存，公有数据，全局变量等 调度器： Java程序中，JVM负责线程的调度，线程的调度是按照特定的机制为多个线程分配CPU的使用权。调度的模式有两种：分时调度和抢占式调度。分时调度是指所有线程轮流获得CPU的使用权，并平均分配每个线程占用CPU的时间；抢占式调度是根据线程的优先级别来获取CPU的使用权。JVM的线程调度模式采用抢占式模式。 线程的四种属性 编号-tid 线程的编号（id）用于标识不同的线程，每条线程拥有不同的编号。需要注意的是，编号不能作为唯一标示，某个线程运行结束后，该编号可能被新的线程重用。编号是只读的不能被修改 名称-name 线程的默认名称是Thread-线程编号，在新建线程时我们可以通过构造函数来为线程命名 1Thread thread=new Thread(&quot;name&quot;); 类别-daemon 守护线程（DaemonThread） 守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。我们可以通过 setDaemon(true) 把线程设置为守护线程。 用户线程 默认创建的都是用户线程 优先级-priority JVM的线程调度方式为抢占式，优先级的高低决定了调度器会优先运行哪个线程。java中线程优先级的范围为 1~10，默认值是 5，Thread 中定义了下面三个优先级常量。 优先级 名称 值 最低优先级 MIN_PRIORITY 1 默认优先级 NORM_PRIORITY 5 最高优先级 MAX_PRIORITY 10 线程的六个方法 start() 该方法用于启动线程，需要注意的是：start()只能调用一次，再次调用会抛出异常 run() 重写Thread或者Runnable所需要实现的方法，为任务的具体逻辑，该方法由JVM调用，一般不需要手动调用 join() 用于等待其他线程结束后继续执行，如A线程运行中，B线程调用了A线程的join()，那么A线程会停止执行等待B线程执行结束后继续执行。join() 方法导致的等待状态是可以被中断的，所以调用这个方法需要捕获中断异常 12345678910111213141516171819202122public static void main(String[] args) { Thread threadB = new Thread(() -&gt; { System.out.println(&quot;B:你先等等，我先来&quot;); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;B:好了，我走了&quot;); }); Thread threadA = new Thread(() -&gt; { System.out.println(&quot;A:我要开始装逼了&quot;); try { threadB.start(); threadB.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;A:我又开始了&quot;); }); threadA.start(); } 让我们开始装～，哦不对运行 Thread.currentThread() currentThread() 方法是一个静态方法，用于获取执行当前方法的线程。 我们可以在任意方法中调用 Thread.currentThread() 获取当前线程，并设置它的名字和优先级等属性。 Thread.yield() 用于使当前线程放弃对处理器的占用，如果有其他线程需要运行，当前线程会处于暂停状态 调用该方法就像是是对线程调度器说：“如果其他线程要处理器资源，那就给它们，否则我继续用”。该方法不一定会让线程进入暂停状态。 Thread.sleep(ms) 用于使当前线程在指定时间内休眠（暂停)，该状态可能会被中断，也需要捕获异常 线程的状态 新建状态 当线程创建完毕，未调用start ()时处于新建状态 就绪状态 调用start()后，此时线程处于就绪状态也就是可运行状态，此时还不会执行run()方法 运行状态 当调度器调用该线程后，该线程会执行run()方法，线程处于运行状态 阻塞状态 当下面几种情况发生时，线程就处于阻塞（BLOCKED）状态。 发起阻塞式 I/O 操作 其他线程调用join()方法 调用sleep()方法 申请其他线程持有的锁 进入一个 synchronized 方法或代码块失败 死亡状态 当线程的任务执行完毕或者任务执行遇到异常时，线程就处于终止（TERMINATED）状态，线程死亡后不能再被重新启动","link":"/2020/11/24/Thead_1/"}],"tags":[{"name":"Thread","slug":"Thread","link":"/tags/Thread/"}],"categories":[]}